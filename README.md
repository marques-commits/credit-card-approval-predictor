Step 1: Problem Definition and Dataset
The goal is to predict whether a credit card application will be approved based on applicant’s information. This helps customers avoid rejections that damage credit scores and waste time, allowing them to target suitable credit cards and improve financial decisions. Machine learning is the best approach for this because it identifies complex patterns in data more accurately than manual rules or the “eye test”, providing personalized predictions and reducing bias.
Dataset: Credit Card Approval Prediction (Kaggle) – https://www.kaggle.com/datasets/rikdifos/credit-card-approval-prediction Files: application_record.csv (applicant details) and credit_record.csv (credit history) were merged on 'ID', containing ~438k rows. Features include income, employment days, family size, etc. Target is approval status (engineered from STATUS: 1 = approved, 0 = not). The top four features used are: AMT_INCOME_TOTAL (total annual income), DAYS_EMPLOYED (how long they have been employed), CNT_FAM_MEMBERS (number of dependents), and credit_history_proxy (mean good months from STATUS).
Step 2: Data Exploration, Cleaning, Feature Engineering, Selection, Training
Data was explored and cleaned in train_model.py using VS Code. Merged datasets on 'ID', dropped rows with missing key values. Engineered credit_history_proxy (mean good payment months). Categorical columns were encoded with LabelEncoder. Selected the top 4 features which are: income, employment years, family size, credit history proxy. The data was split 75/25 (random_state=42),  using RandomForestClassifier (100 estimators) for classification. Accuracy: 0.7183. Model and encoders were then saved and uploaded to GitHub.
Step 3: Local Flask API Deployment
The model was deployed locally with Flask in app.py. The app loads the model and serves a form in templates/index. The users enter their income, employment years, dependents, and credit history proxy. POST request to /predict returns "Approved" or "Not Approved". Run locally with python app.py at URL: http://127.0.0. 1:5000/.  
Step 4: CI/CD Pipeline & Heroku Deployment
The next steo was to create the CI/CD pipeline by connecting GitHub repo to Heroku. Pushed the code with ‘git push heroku main’ and scaled dyno (heroku ps:scale web=1). The live URL is https://credit-card-predictor-ana680-440739f5cdd1.herokuapp.com/ 
Note: Model file was excluded from push due to 100 MB limit; app deploys successfully.
 
Step 5: Containerization & Docker Hub
The app was containerized with Dockerfile (python:3.12-slim base, installs requirements, copies files, runs Gunicorn on port 5000). Built image: docker build -t credit-card-predictor .. Tagged: docker tag credit-card-predictor marques680/credit-card-predictor:latest. Pushed: docker push marques680/credit-card-predictor:latest. After a few attempts I was able to view the Docker Hub URL: https://hub.docker.com/r/marques680/credit-card-predictor.  

Step 6: AWS EC2 Deployment
Launched t2.micro instance with HTTP (80) and SSH (22) open. Connected via EC2 Instance Connect. Installed Docker, pulled image (docker pull marques680/credit-card-predictor:latest), ran container (docker run -d -p 80:5000 ...). Installed NGINX (sudo dnf install nginx -y), configured reverse proxy (/etc/nginx/conf.d/app.conf), restarted NGINX. Finally was up and running, live at http://18.118.93.135
